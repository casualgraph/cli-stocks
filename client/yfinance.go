// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package client

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for Interval.
const (
	IntervalN15m Interval = "15m"
	IntervalN1d  Interval = "1d"
	IntervalN1h  Interval = "1h"
	IntervalN1m  Interval = "1m"
	IntervalN30m Interval = "30m"
	IntervalN5m  Interval = "5m"
	IntervalN6h  Interval = "6h"
)

// Defines values for Range.
const (
	RangeMax  Range = "max"
	RangeN10y Range = "10y"
	RangeN1d  Range = "1d"
	RangeN1mo Range = "1mo"
	RangeN1y  Range = "1y"
	RangeN2y  Range = "2y"
	RangeN3mo Range = "3mo"
	RangeN5d  Range = "5d"
	RangeN5y  Range = "5y"
	RangeN6mo Range = "6mo"
	RangeYtd  Range = "ytd"
)

// Defines values for GetQuoteParamsRegion.
const (
	GetQuoteParamsRegionUS GetQuoteParamsRegion = "US"
)

// Defines values for GetQuoteParamsLang.
const (
	GetQuoteParamsLangEnUS GetQuoteParamsLang = "en-US"
)

// Defines values for GetQuoteParamsCorsDomain.
const (
	GetQuoteParamsCorsDomainFinanceYahooCom GetQuoteParamsCorsDomain = "finance.yahoo.com"
)

// Defines values for SparkParamsLang.
const (
	SparkParamsLangEnUS SparkParamsLang = "en-US"
)

// Defines values for SparkParamsCorsDomain.
const (
	SparkParamsCorsDomainFinanceYahooCom SparkParamsCorsDomain = "finance.yahoo.com"
)

// Defines values for GetChartParamsRegion.
const (
	GetChartParamsRegionUS GetChartParamsRegion = "US"
)

// Defines values for GetChartParamsEvents.
const (
	Div   GetChartParamsEvents = "div"
	Split GetChartParamsEvents = "split"
)

// Defines values for GetChartParamsLang.
const (
	EnUS GetChartParamsLang = "en-US"
)

// Defines values for GetChartParamsCorsDomain.
const (
	FinanceYahooCom GetChartParamsCorsDomain = "finance.yahoo.com"
)

// Defines values for GetChartParamsTsrc.
const (
	Finance GetChartParamsTsrc = "finance"
)

// ChartResponse defines model for ChartResponse.
type ChartResponse struct {
	Chart *struct {
		Error  *Error `json:"error,omitempty"`
		Result *[]struct {
			Indicators *struct {
				Quote *[]struct {
					Close  *[]float32 `json:"close,omitempty"`
					High   *[]float32 `json:"high,omitempty"`
					Low    *[]float32 `json:"low,omitempty"`
					Open   *[]float32 `json:"open,omitempty"`
					Volume *[]int32   `json:"volume,omitempty"`
				} `json:"quote,omitempty"`
			} `json:"indicators,omitempty"`
			Meta *struct {
				ChartPreviousClose   *float32 `json:"chartPreviousClose,omitempty"`
				Currency             *string  `json:"currency,omitempty"`
				CurrentTradingPeriod *struct {
					Post *struct {
						End       *int32  `json:"end,omitempty"`
						Gmtoffset *int32  `json:"gmtoffset,omitempty"`
						Start     *int32  `json:"start,omitempty"`
						Timezone  *string `json:"timezone,omitempty"`
					} `json:"post,omitempty"`
					Pre *struct {
						End       *int32  `json:"end,omitempty"`
						Gmtoffset *int32  `json:"gmtoffset,omitempty"`
						Start     *int32  `json:"start,omitempty"`
						Timezone  *string `json:"timezone,omitempty"`
					} `json:"pre,omitempty"`
					Regular *struct {
						End       *int32  `json:"end,omitempty"`
						Gmtoffset *int32  `json:"gmtoffset,omitempty"`
						Start     *int32  `json:"start,omitempty"`
						Timezone  *string `json:"timezone,omitempty"`
					} `json:"regular,omitempty"`
				} `json:"currentTradingPeriod,omitempty"`
				DataGranularity      *string  `json:"dataGranularity,omitempty"`
				ExchangeName         *string  `json:"exchangeName,omitempty"`
				ExchangeTimezoneName *string  `json:"exchangeTimezoneName,omitempty"`
				FirstTradeDate       *int32   `json:"firstTradeDate,omitempty"`
				Gmtoffset            *int32   `json:"gmtoffset,omitempty"`
				InstrumentType       *string  `json:"instrumentType,omitempty"`
				PreviousClose        *float32 `json:"previousClose,omitempty"`
				PriceHint            *int32   `json:"priceHint,omitempty"`
				Range                *string  `json:"range,omitempty"`
				RegularMarketPrice   *float32 `json:"regularMarketPrice,omitempty"`
				RegularMarketTime    *int32   `json:"regularMarketTime,omitempty"`
				Scale                *int32   `json:"scale,omitempty"`
				Symbol               *string  `json:"symbol,omitempty"`
				Timezone             *string  `json:"timezone,omitempty"`
				TradingPeriods       *[][]struct {
					End       *int32  `json:"end,omitempty"`
					Gmtoffset *int32  `json:"gmtoffset,omitempty"`
					Start     *int32  `json:"start,omitempty"`
					Timezone  *string `json:"timezone,omitempty"`
				} `json:"tradingPeriods,omitempty"`
				ValidRanges *[]string `json:"validRanges,omitempty"`
			} `json:"meta,omitempty"`
			Timestamp *[]int32 `json:"timestamp,omitempty"`
		} `json:"result,omitempty"`
	} `json:"chart,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Code        *string `json:"code,omitempty"`
	Description *string `json:"description,omitempty"`
}

// Interval defines model for Interval.
type Interval string

// QuoteResponse defines model for QuoteResponse.
type QuoteResponse struct {
	QuoteResponse *struct {
		Error  *Error         `json:"error,omitempty"`
		Result *[]QuoteResult `json:"result,omitempty"`
	} `json:"quoteResponse,omitempty"`
}

// QuoteResult defines model for QuoteResult.
type QuoteResult struct {
	Currency                  *string `json:"currency,omitempty"`
	Exchange                  *string `json:"exchange,omitempty"`
	ExchangeDataDelayedBy     *int32  `json:"exchangeDataDelayedBy,omitempty"`
	ExchangeTimezoneName      *string `json:"exchangeTimezoneName,omitempty"`
	ExchangeTimezoneShortName *string `json:"exchangeTimezoneShortName,omitempty"`
	FiftyTwoWeekHigh          *struct {
		Fmt *string  `json:"fmt,omitempty"`
		Raw *float32 `json:"raw,omitempty"`
	} `json:"fiftyTwoWeekHigh,omitempty"`
	FiftyTwoWeekHighChange *struct {
		Fmt *string  `json:"fmt,omitempty"`
		Raw *float32 `json:"raw,omitempty"`
	} `json:"fiftyTwoWeekHighChange,omitempty"`
	FiftyTwoWeekHighChangePercent *struct {
		Fmt *string  `json:"fmt,omitempty"`
		Raw *float32 `json:"raw,omitempty"`
	} `json:"fiftyTwoWeekHighChangePercent,omitempty"`
	FiftyTwoWeekLow *struct {
		Fmt *string  `json:"fmt,omitempty"`
		Raw *float32 `json:"raw,omitempty"`
	} `json:"fiftyTwoWeekLow,omitempty"`
	FiftyTwoWeekLowChange *struct {
		Fmt *string  `json:"fmt,omitempty"`
		Raw *float32 `json:"raw,omitempty"`
	} `json:"fiftyTwoWeekLowChange,omitempty"`
	FiftyTwoWeekLowChangePercent *struct {
		Fmt *string  `json:"fmt,omitempty"`
		Raw *float32 `json:"raw,omitempty"`
	} `json:"fiftyTwoWeekLowChangePercent,omitempty"`
	FiftyTwoWeekRange *struct {
		Fmt *string `json:"fmt,omitempty"`
		Raw *string `json:"raw,omitempty"`
	} `json:"fiftyTwoWeekRange,omitempty"`
	FirstTradeDateMilliseconds *int64  `json:"firstTradeDateMilliseconds,omitempty"`
	FullExchangeName           *string `json:"fullExchangeName,omitempty"`
	GmtOffSetMilliseconds      *int32  `json:"gmtOffSetMilliseconds,omitempty"`
	Language                   *string `json:"language,omitempty"`
	Market                     *string `json:"market,omitempty"`
	MarketState                *string `json:"marketState,omitempty"`
	MessageBoardId             *string `json:"messageBoardId,omitempty"`
	PriceHint                  *int32  `json:"priceHint,omitempty"`
	QuoteSourceName            *string `json:"quoteSourceName,omitempty"`
	QuoteType                  *string `json:"quoteType,omitempty"`
	Region                     *string `json:"region,omitempty"`
	RegularMarketChange        *struct {
		Fmt *string  `json:"fmt,omitempty"`
		Raw *float32 `json:"raw,omitempty"`
	} `json:"regularMarketChange,omitempty"`
	RegularMarketChangePercent *struct {
		Fmt *string  `json:"fmt,omitempty"`
		Raw *float32 `json:"raw,omitempty"`
	} `json:"regularMarketChangePercent,omitempty"`
	RegularMarketDayHigh *struct {
		Fmt *string  `json:"fmt,omitempty"`
		Raw *float32 `json:"raw,omitempty"`
	} `json:"regularMarketDayHigh,omitempty"`
	RegularMarketDayLow *struct {
		Fmt *string  `json:"fmt,omitempty"`
		Raw *float32 `json:"raw,omitempty"`
	} `json:"regularMarketDayLow,omitempty"`
	RegularMarketDayRange *struct {
		Fmt *string `json:"fmt,omitempty"`
		Raw *string `json:"raw,omitempty"`
	} `json:"regularMarketDayRange,omitempty"`
	RegularMarketOpen *struct {
		Fmt *string  `json:"fmt,omitempty"`
		Raw *float32 `json:"raw,omitempty"`
	} `json:"regularMarketOpen,omitempty"`
	RegularMarketPreviousClose *struct {
		Fmt *string  `json:"fmt,omitempty"`
		Raw *float32 `json:"raw,omitempty"`
	} `json:"regularMarketPreviousClose,omitempty"`
	RegularMarketPrice *struct {
		Fmt *string  `json:"fmt,omitempty"`
		Raw *float32 `json:"raw,omitempty"`
	} `json:"regularMarketPrice,omitempty"`
	RegularMarketTime *struct {
		Fmt *string `json:"fmt,omitempty"`
		Raw *int32  `json:"raw,omitempty"`
	} `json:"regularMarketTime,omitempty"`
	RegularMarketVolume *struct {
		Fmt     *string `json:"fmt,omitempty"`
		LongFmt *string `json:"longFmt,omitempty"`
		Raw     *int64  `json:"raw,omitempty"`
	} `json:"regularMarketVolume,omitempty"`
	ShortName      *string `json:"shortName,omitempty"`
	SourceInterval *int32  `json:"sourceInterval,omitempty"`
	Symbol         *string `json:"symbol,omitempty"`
	Tradeable      *bool   `json:"tradeable,omitempty"`
	Triggerable    *bool   `json:"triggerable,omitempty"`
	Uuid           *string `json:"uuid,omitempty"`
}

// Range defines model for Range.
type Range string

// GetQuoteParams defines parameters for GetQuote.
type GetQuoteParams struct {
	Formatted      *bool                     `form:"formatted,omitempty" json:"formatted,omitempty"`
	Region         *GetQuoteParamsRegion     `form:"region,omitempty" json:"region,omitempty"`
	Lang           *GetQuoteParamsLang       `form:"lang,omitempty" json:"lang,omitempty"`
	IncludePrePost *bool                     `form:"includePrePost,omitempty" json:"includePrePost,omitempty"`
	Fields         *string                   `form:"fields,omitempty" json:"fields,omitempty"`
	CorsDomain     *GetQuoteParamsCorsDomain `form:"corsDomain,omitempty" json:"corsDomain,omitempty"`
	Symbols        string                    `form:"symbols" json:"symbols"`
}

// GetQuoteParamsRegion defines parameters for GetQuote.
type GetQuoteParamsRegion string

// GetQuoteParamsLang defines parameters for GetQuote.
type GetQuoteParamsLang string

// GetQuoteParamsCorsDomain defines parameters for GetQuote.
type GetQuoteParamsCorsDomain string

// SparkParams defines parameters for Spark.
type SparkParams struct {
	Interval          Interval               `form:"interval" json:"interval"`
	Range             Range                  `form:"range" json:"range"`
	Lang              *SparkParamsLang       `form:"lang,omitempty" json:"lang,omitempty"`
	IncludePrePost    *bool                  `form:"includePrePost,omitempty" json:"includePrePost,omitempty"`
	IncludeTimestamps *bool                  `form:"includeTimestamps,omitempty" json:"includeTimestamps,omitempty"`
	Indicators        *string                `form:"indicators,omitempty" json:"indicators,omitempty"`
	CorsDomain        *SparkParamsCorsDomain `form:"corsDomain,omitempty" json:"corsDomain,omitempty"`
	Symbols           string                 `form:"symbols" json:"symbols"`
}

// SparkParamsLang defines parameters for Spark.
type SparkParamsLang string

// SparkParamsCorsDomain defines parameters for Spark.
type SparkParamsCorsDomain string

// GetChartParams defines parameters for GetChart.
type GetChartParams struct {
	Region         *GetChartParamsRegion     `form:"region,omitempty" json:"region,omitempty"`
	IncludePrePost *bool                     `form:"includePrePost,omitempty" json:"includePrePost,omitempty"`
	Events         *[]GetChartParamsEvents   `json:"events,omitempty"`
	Lang           *GetChartParamsLang       `form:"lang,omitempty" json:"lang,omitempty"`
	Interval       Interval                  `form:"interval" json:"interval"`
	UseYfid        *bool                     `form:"useYfid,omitempty" json:"useYfid,omitempty"`
	Period1        int64                     `form:"period1" json:"period1"`
	Period2        int64                     `form:"period2" json:"period2"`
	CorsDomain     *GetChartParamsCorsDomain `form:"corsDomain,omitempty" json:"corsDomain,omitempty"`
	DotTsrc        *GetChartParamsTsrc       `form:".tsrc,omitempty" json:".tsrc,omitempty"`
}

// GetChartParamsRegion defines parameters for GetChart.
type GetChartParamsRegion string

// GetChartParamsEvents defines parameters for GetChart.
type GetChartParamsEvents string

// GetChartParamsLang defines parameters for GetChart.
type GetChartParamsLang string

// GetChartParamsCorsDomain defines parameters for GetChart.
type GetChartParamsCorsDomain string

// GetChartParamsTsrc defines parameters for GetChart.
type GetChartParamsTsrc string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetQuote request
	GetQuote(ctx context.Context, params *GetQuoteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Spark request
	Spark(ctx context.Context, params *SparkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChart request
	GetChart(ctx context.Context, symbol string, params *GetChartParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetQuote(ctx context.Context, params *GetQuoteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQuoteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Spark(ctx context.Context, params *SparkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSparkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChart(ctx context.Context, symbol string, params *GetChartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChartRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetQuoteRequest generates requests for GetQuote
func NewGetQuoteRequest(server string, params *GetQuoteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v7/finance/quote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Formatted != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "formatted", runtime.ParamLocationQuery, *params.Formatted); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Region != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Lang != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludePrePost != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includePrePost", runtime.ParamLocationQuery, *params.IncludePrePost); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Fields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CorsDomain != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "corsDomain", runtime.ParamLocationQuery, *params.CorsDomain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSparkRequest generates requests for Spark
func NewSparkRequest(server string, params *SparkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v7/finance/spark")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, params.Interval); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, params.Range); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Lang != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludePrePost != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includePrePost", runtime.ParamLocationQuery, *params.IncludePrePost); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeTimestamps != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeTimestamps", runtime.ParamLocationQuery, *params.IncludeTimestamps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Indicators != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "indicators", runtime.ParamLocationQuery, *params.Indicators); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CorsDomain != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "corsDomain", runtime.ParamLocationQuery, *params.CorsDomain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChartRequest generates requests for GetChart
func NewGetChartRequest(server string, symbol string, params *GetChartParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v8/finance/chart/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Region != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludePrePost != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includePrePost", runtime.ParamLocationQuery, *params.IncludePrePost); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Events != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("pipeDelimited", false, "events", runtime.ParamLocationQuery, *params.Events); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Lang != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, params.Interval); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.UseYfid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useYfid", runtime.ParamLocationQuery, *params.UseYfid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period1", runtime.ParamLocationQuery, params.Period1); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period2", runtime.ParamLocationQuery, params.Period2); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.CorsDomain != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "corsDomain", runtime.ParamLocationQuery, *params.CorsDomain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DotTsrc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, ".tsrc", runtime.ParamLocationQuery, *params.DotTsrc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetQuote request
	GetQuoteWithResponse(ctx context.Context, params *GetQuoteParams, reqEditors ...RequestEditorFn) (*GetQuoteResponse, error)

	// Spark request
	SparkWithResponse(ctx context.Context, params *SparkParams, reqEditors ...RequestEditorFn) (*SparkResponse, error)

	// GetChart request
	GetChartWithResponse(ctx context.Context, symbol string, params *GetChartParams, reqEditors ...RequestEditorFn) (*GetChartResponse, error)
}

type GetQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuoteResponse
}

// Status returns HTTPResponse.Status
func (r GetQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SparkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuoteResponse
}

// Status returns HTTPResponse.Status
func (r SparkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SparkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChartResponse
}

// Status returns HTTPResponse.Status
func (r GetChartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetQuoteWithResponse request returning *GetQuoteResponse
func (c *ClientWithResponses) GetQuoteWithResponse(ctx context.Context, params *GetQuoteParams, reqEditors ...RequestEditorFn) (*GetQuoteResponse, error) {
	rsp, err := c.GetQuote(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQuoteResponse(rsp)
}

// SparkWithResponse request returning *SparkResponse
func (c *ClientWithResponses) SparkWithResponse(ctx context.Context, params *SparkParams, reqEditors ...RequestEditorFn) (*SparkResponse, error) {
	rsp, err := c.Spark(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSparkResponse(rsp)
}

// GetChartWithResponse request returning *GetChartResponse
func (c *ClientWithResponses) GetChartWithResponse(ctx context.Context, symbol string, params *GetChartParams, reqEditors ...RequestEditorFn) (*GetChartResponse, error) {
	rsp, err := c.GetChart(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChartResponse(rsp)
}

// ParseGetQuoteResponse parses an HTTP response from a GetQuoteWithResponse call
func ParseGetQuoteResponse(rsp *http.Response) (*GetQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuoteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSparkResponse parses an HTTP response from a SparkWithResponse call
func ParseSparkResponse(rsp *http.Response) (*SparkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SparkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuoteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChartResponse parses an HTTP response from a GetChartWithResponse call
func ParseGetChartResponse(rsp *http.Response) (*GetChartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChartResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Returns quotes for the specified symbols
	// (GET /v7/finance/quote)
	GetQuote(ctx echo.Context, params GetQuoteParams) error

	// (GET /v7/finance/spark)
	Spark(ctx echo.Context, params SparkParams) error

	// (GET /v8/finance/chart/{symbol})
	GetChart(ctx echo.Context, symbol string, params GetChartParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetQuote converts echo context to params.
func (w *ServerInterfaceWrapper) GetQuote(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetQuoteParams
	// ------------- Optional query parameter "formatted" -------------

	err = runtime.BindQueryParameter("form", true, false, "formatted", ctx.QueryParams(), &params.Formatted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter formatted: %s", err))
	}

	// ------------- Optional query parameter "region" -------------

	err = runtime.BindQueryParameter("form", true, false, "region", ctx.QueryParams(), &params.Region)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region: %s", err))
	}

	// ------------- Optional query parameter "lang" -------------

	err = runtime.BindQueryParameter("form", true, false, "lang", ctx.QueryParams(), &params.Lang)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lang: %s", err))
	}

	// ------------- Optional query parameter "includePrePost" -------------

	err = runtime.BindQueryParameter("form", true, false, "includePrePost", ctx.QueryParams(), &params.IncludePrePost)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includePrePost: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "corsDomain" -------------

	err = runtime.BindQueryParameter("form", true, false, "corsDomain", ctx.QueryParams(), &params.CorsDomain)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter corsDomain: %s", err))
	}

	// ------------- Required query parameter "symbols" -------------

	err = runtime.BindQueryParameter("form", true, true, "symbols", ctx.QueryParams(), &params.Symbols)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbols: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetQuote(ctx, params)
	return err
}

// Spark converts echo context to params.
func (w *ServerInterfaceWrapper) Spark(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SparkParams
	// ------------- Required query parameter "interval" -------------

	err = runtime.BindQueryParameter("form", true, true, "interval", ctx.QueryParams(), &params.Interval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter interval: %s", err))
	}

	// ------------- Required query parameter "range" -------------

	err = runtime.BindQueryParameter("form", true, true, "range", ctx.QueryParams(), &params.Range)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter range: %s", err))
	}

	// ------------- Optional query parameter "lang" -------------

	err = runtime.BindQueryParameter("form", true, false, "lang", ctx.QueryParams(), &params.Lang)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lang: %s", err))
	}

	// ------------- Optional query parameter "includePrePost" -------------

	err = runtime.BindQueryParameter("form", true, false, "includePrePost", ctx.QueryParams(), &params.IncludePrePost)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includePrePost: %s", err))
	}

	// ------------- Optional query parameter "includeTimestamps" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeTimestamps", ctx.QueryParams(), &params.IncludeTimestamps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeTimestamps: %s", err))
	}

	// ------------- Optional query parameter "indicators" -------------

	err = runtime.BindQueryParameter("form", true, false, "indicators", ctx.QueryParams(), &params.Indicators)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter indicators: %s", err))
	}

	// ------------- Optional query parameter "corsDomain" -------------

	err = runtime.BindQueryParameter("form", true, false, "corsDomain", ctx.QueryParams(), &params.CorsDomain)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter corsDomain: %s", err))
	}

	// ------------- Required query parameter "symbols" -------------

	err = runtime.BindQueryParameter("form", true, true, "symbols", ctx.QueryParams(), &params.Symbols)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbols: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Spark(ctx, params)
	return err
}

// GetChart converts echo context to params.
func (w *ServerInterfaceWrapper) GetChart(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "symbol" -------------
	var symbol string

	err = runtime.BindStyledParameterWithLocation("simple", false, "symbol", runtime.ParamLocationPath, ctx.Param("symbol"), &symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChartParams
	// ------------- Optional query parameter "region" -------------

	err = runtime.BindQueryParameter("form", true, false, "region", ctx.QueryParams(), &params.Region)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region: %s", err))
	}

	// ------------- Optional query parameter "includePrePost" -------------

	err = runtime.BindQueryParameter("form", true, false, "includePrePost", ctx.QueryParams(), &params.IncludePrePost)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includePrePost: %s", err))
	}

	// ------------- Optional query parameter "events" -------------

	err = runtime.BindQueryParameter("pipeDelimited", false, false, "events", ctx.QueryParams(), &params.Events)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter events: %s", err))
	}

	// ------------- Optional query parameter "lang" -------------

	err = runtime.BindQueryParameter("form", true, false, "lang", ctx.QueryParams(), &params.Lang)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lang: %s", err))
	}

	// ------------- Required query parameter "interval" -------------

	err = runtime.BindQueryParameter("form", true, true, "interval", ctx.QueryParams(), &params.Interval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter interval: %s", err))
	}

	// ------------- Optional query parameter "useYfid" -------------

	err = runtime.BindQueryParameter("form", true, false, "useYfid", ctx.QueryParams(), &params.UseYfid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter useYfid: %s", err))
	}

	// ------------- Required query parameter "period1" -------------

	err = runtime.BindQueryParameter("form", true, true, "period1", ctx.QueryParams(), &params.Period1)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter period1: %s", err))
	}

	// ------------- Required query parameter "period2" -------------

	err = runtime.BindQueryParameter("form", true, true, "period2", ctx.QueryParams(), &params.Period2)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter period2: %s", err))
	}

	// ------------- Optional query parameter "corsDomain" -------------

	err = runtime.BindQueryParameter("form", true, false, "corsDomain", ctx.QueryParams(), &params.CorsDomain)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter corsDomain: %s", err))
	}

	// ------------- Optional query parameter ".tsrc" -------------

	err = runtime.BindQueryParameter("form", true, false, ".tsrc", ctx.QueryParams(), &params.DotTsrc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter .tsrc: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChart(ctx, symbol, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v7/finance/quote", wrapper.GetQuote)
	router.GET(baseURL+"/v7/finance/spark", wrapper.Spark)
	router.GET(baseURL+"/v8/finance/chart/:symbol", wrapper.GetChart)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xaW3PbuBX+Kxy0fZN5FS/SzD5sbG8208RWLbvdzDbNQOShhA0JMAAoR5vxf+8ApGRT",
	"omRIuezstH7gyMTBwYeDcwc/o5SVFaNApUDjz0ikCyix/nm+wFzegKgYFaBeVJxVwCUBPZyq4d3XwDnj",
	"6sdfOeRojP7iPC7gtNydS030MEAcRF1oLkRCKXbZEZqRFEvGe8Y+1kzCgblpwUR3HD7hsioAjT3bixM/",
	"9mN/6IVe5HnBAMlVBWiMaF3OQINrX2DO8Ur9vyDzxQF2Q88bJkEcDaNhMjRgV7D7rwiOVUC/IrglK+py",
	"j/DcAcoZL7FEY0SoDHy0mU+ohHkfx8cXbPYbpNKMogSJ92jehMOSsFqcrw+5u9+eLaY150DTVYcY3U0v",
	"HuELyQmdPxLLW44zQucT4IRlu0gqJvpMgGZdQJEXD91hMDQT3LyULM8FyA6TIHLNpgvZ2uWp60tSwu+M",
	"doWKXkxvd+XUd2YVBzORBF7iun+gSI5Y/wtFwmFeF5j/OTTle4mlT1AZlvglx1RJi8gtS/XLPkOFT+kC",
	"0zlc4XILx/n520MTblvwuxMva3VIzmtGM0b7WOSEC+0a4ALLLefjxq4fRMn3UWxCheR1qRyVHuts/+7m",
	"5vKqXwbV0c6z4iSFnwntAh0aoeRK3F1wXtYHq7WTN5h/ADlRK+5gi0Y94Drz1LnuKvUoGcUjM6tIcQEn",
	"7FKsyhkrtjTp7uZuevHDL32bPcJ4Bkg+jUOiE5b3JD//y65lN53ZSW9wQbIbpZeiP8fZo6EGSQ0pQUhc",
	"VnuSsSPF8MVJVN+cy3WOvpVXsWxL3ne04iwFIfCsAOuSSuWUe8SSgUg5qSRhdEuKpaV8ukWZtPASk0Iz",
	"yhm3tIYoW/3Bi7xkFLluHFiYZhbQrH3t+6F+bVvXtFhZsZXhlbDuGZcLi+WWV1rzx1jRrIM5WLgo2D1k",
	"lmTWDKwcZLqAzKqAWxw+1iCkbaZDr6gEvsSNSdO6RONfkadiUKgenn4Grv69QAMUqYeXoXc98vmHqlT2",
	"l1IfDw9/cUl1aN4amppzojo9ZbGrVMdk3evY3CWeXk0OEV9giS+gwCvIXqxOKFSeTwh+LIGTFDtXcP/+",
	"LeMfTNKK6YJx2ZNbXNz2ZxS5XN3es38BfPi5LTO7cszLrj9FQ9d37SjojaP4vhvAGtKdyNl3mNtIzjcH",
	"8gyeM9eOIxM0ijAcxVEYfQGgCfAUqDTD5fp/MwTmuq6XJKMoSvyjwb1u6vln4PhhPLTD2ARPS3oKEONT",
	"84bD0DZSoobydDDmJxZGtjc0OjHXDiMviMPjYd0Yyqc9A+vMOsLeTGb1A3xaV7whRUEEpIxm3RzizAv8",
	"MEwCV/91fVw07PVxeV0Ul3srpT0Odl7K6zyfgjyAZDjsAbHH0RaYzmu87d2Bnt1N+5YvdTrfJa7F+/b1",
	"3glTuV2TofPX19PL3oBTqtxmDi8Y5tmrbsKMckLL2ftXVxeXv7ycTs7766i+qsg3koYO+lNW87TnRNp4",
	"ZunQ2reynr1b9Gm0e0qrneSsX+ydYsrYjwwje5QYxSJF6Pp+aGSyPWDM/Yhne4mRG1GEfui7/vGYLvDq",
	"j43X22jMolAwGgV2bHRgLelJYEy9bDAa+XacHOllDWY9C/K6bZubATSUl3+SvHY62s9iin07GZlh0qSn",
	"YGqbMM8qtzeyk9hMuTXp8VjWjZ3nsoexF07eWHsS7R3T1/W4F/smTvtZiP/c3Jo8l1bYXhS+6ANYMDr/",
	"aYfci8JhGMdBaJQ3bqgNcoO+PYn+2mX679p1/Whiha7bh0PoYNYpmzdiDk/uof1nX/CVKlHCs6ZZ147O",
	"GCsA02aYzOfA9xPUNdmK+EmeZ2GYeWdB5mVnQRwEZ3iYuGdhFEfJLI3dBCIzH7NxfJvGQYYGKFQPr2Ro",
	"gAL9jPTTW6EB8tUjVA/PVc+VVMQl/tTTUHjQrd+cNU0bKnGq9aXmBRqjhZSVGDvOAorKXuEFY3bKSufD",
	"zMkJxTSFs5zxs3uY7TRu0FtFbf3UkFk/Tl5ZooKU5CTFmmKACpJC26OgWj/QjxVOF2D5tlKJRwRjx7m/",
	"v7exHrUZnzvtVOG8fnV+eTW9PPNt117IstCHBbwU1/kU+FI7nM0uFJMlcPI7oyVkBOu9VKwgKQHh1MIB",
	"6jwddzQnh0kmHEIz+NQsMUCSSH3GnT2iAVoCF83uPdu1k/VVKq6IcrG2q/dVYbnQhuws47UYnc3187zJ",
	"UruyvAFZcyosTSV0y0suYC1QyKxG1wXS63EtYJWBopcg11lfhTkuQQIXaPzrZ0QU3481cKUfrfgbo5Kg",
	"lKVp6TRQcqy7MTkuBAx2lP9h0M+tzRKfslor8N20TxH38FGZfi+XJtk3Z0RoWtQZTDhMmJBfZY85gSIT",
	"HVaGYFLGxQUrMemXUKsXjzZ3xD4flYHDx5pwyNBY8hoOoXyne326Z6h103fdtUNo82NcVUVru85vokn/",
	"H/mZdAWbjqR2OF31vv67dnyiLkvMV8fpu8RzpdDt9xvvFJ+ndiUqzD88sauueUz1qJFtkHUkOiTVQ1LY",
	"hLL9BqP9/Kn8myjxp7SiluXt+rZDfCWum699/m+fX8M+16bW2FRrasnG1PSXNM7nZncPe23upa69udxj",
	"dio6bovqKEl942j0heoPn6pC34y1NH1LwFJ/QPeU9ePdX4s5I0tFUBVE9l4Sbd9RCrnSGUtFKriAgpRE",
	"hfnv4Cy+udesBbzNyZ6UpVnK1GNU+kbcOwjWoAY6xNz/Nsy/obeypeDpIa59vL6lu+p+Svq8u2q+LX2n",
	"CQXw5drddCscvWvP3pWU2kvLalOnNCyVxNoXTfbx5EXjIx/ePfw3AAD///Pu1qUUKwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
